{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../lib/utils.ts"],"names":[],"mappings":";;;;;AAEA,2CAAqC;AACrC,+CAA6C;AAC7C,4DAAmC;AAEnC,MAAqB,KAAK;IAcjB,eAAe,CAAG,QAAgB;QACvC,MAAM,OAAO,GAAG,kBAAQ,CAAC,QAAQ,CAAC,CAAC;QACnC,OAAS,EAAgB;aACtB,MAAM,CAAE,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,GAAG,CAAE;aAChE,GAAG,CAAE,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,CAAE,MAAM,EAAE,EAAE,CAAE,CAAE;aAC/C,MAAM,CAAE,OAAO,CAAC,EAAE,CAAC,OAAO,KAAK,GAAG,CAAE,CAAC;IAC1C,CAAC;IASM,gBAAgB,CAAG,UAAiC;QACzD,IAAK,UAAU,CAAC,KAAK,KAAK,kBAAM,EAAG;YACjC,OAAO;gBACL,aAAa,EAAE,oBAAS,CAAE,UAAU,CAAC,KAAK,CAAC,KAAK,CAAE;aACnD,CAAC;SACH;QAED,OAAO,EAAE,CAAC;IACZ,CAAC;IAWM,aAAa,CAAG,KAAa,EAAE,QAAgB;QACpD,MAAM,YAAY,GAAG,IAAI,CAAC,eAAe,CAAE,QAAQ,CAAE,CAAC;QACtD,OAAO,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAE,IAAI,CAAC,OAAO,CAAE,CAAE,CAAC;IACrE,CAAC;IAWM,iBAAiB,CAAG,KAAa,EAAE,QAAgB;QACxD,MAAM,YAAY,GAAG,EAAE,CAAC,MAAM,CAAE,IAAI,CAAC,eAAe,CAAE,QAAQ,CAAE,EAAE,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAE,CAAC;QACxF,MAAM,KAAK,GAAG,IAAI,MAAM,CAAE,KAAK,YAAY,CAAC,IAAI,CAAE,GAAG,CAAE,MAAM,CAAE,CAAC;QAChE,OAAO,CAAE,KAAK,CAAC,IAAI,CAAE,KAAK,CAAE,IAAI,EAAE,CAAE,CAAC,GAAG,EAAY,CAAC;IACvD,CAAC;CACF;AAnED,wBAmEC","sourcesContent":["import { ErrorMessage, Step } from './models';\nimport { HookStats, TestStats } from '@wdio/reporter';\nimport { FAILED } from './constants';\nimport { dialects } from '@cucumber/gherkin';\nimport stripAnsi from 'strip-ansi';\n\nexport default class Utils {\n  // readonly utilFunctions = {\n  //     containsSteps,\n  //     getFailedMessage,\n  //     keywordStartsWith,\n  // };\n\n  /**\n   * Return the list of step keywords in the specified language\n   *\n   * @param language {string}\n   *\n   * @return {string[]}\n   */\n  public getStepKeywords ( language: string ): string[] {\n    const dialect = dialects[language];\n    return ( [] as string[] )\n      .concat( dialect.given, dialect.when, dialect.then, dialect.and )\n      .map( keyword => keyword.replace( /\\s*$/, '' ) )\n      .filter( keyword => keyword !== '*' );\n  }\n\n  /**\n   * Add a failed message\n   *\n   * @param {object}  testObject\n   *\n   * @return {object}\n   */\n  public getFailedMessage ( testObject: TestStats | HookStats ): ErrorMessage {\n    if ( testObject.state === FAILED ) {\n      return {\n        error_message: stripAnsi( testObject.error.stack ),\n      };\n    }\n\n    return {};\n  }\n\n  /**\n   * Check if the steps contain valid steps\n   *\n   * @param {array} steps\n   *\n   * @param {string} language\n   *\n   * @return {boolean}\n   */\n  public containsSteps ( steps: Step[], language: string ): boolean {\n    const stepKeywords = this.getStepKeywords( language );\n    return steps.some( step => stepKeywords.includes( step.keyword ) );\n  }\n\n  /**\n   * Returns the first word in case it's a keyword in the specified language\n   *\n   * @param {array} title\n   *\n   * @param {string} language\n   *\n   * @return {string|undefined}\n   */\n  public keywordStartsWith ( title: string, language: string ): string | undefined {\n    const stepKeywords = [].concat( this.getStepKeywords( language ), ['After', 'Before'] );\n    const regex = new RegExp( `^(${stepKeywords.join( '|' )})\\\\s` );\n    return ( regex.exec( title ) || [] ).pop() as string;\n  }\n}\n\n"]}